* to start a react project you can either :
  1 - use webpack
  2 - using a CDN
  3 - Create React App :
      npm install -g create-react-app 
      go where you wanna install you project and run create-react-app projectname

* React is a javascript library that is used to produce html code to the browser 
  
* render function is the one required function in a component


* React library is starting to diverge into to separate libraries :
    1 - core react library 
    2 -  react Dom 

* state concept :
  state is a plain javascript object that is used to record and react to user events.
  each class based component has it's own state object
  functional components don't have a state.

* in a functional component the props object is accessed as an argument 
  but in a class-based component it's available anywhere in any method we define through this.props

* to give a component a class we use className to avoid naming conflict with the keyword class

* props are data passed between components
  

* we only update the state using the setState(). However we define the state inside our constructor
  when setState is called the component rerenders again

* setState takes a second parameter (a callback function)

* this is an example from one of the reducers : 
    check out this link also : https://stackoverflow.com/questions/37435334/correct-way-to-push-into-state-array

    return state.push(action.payload.data), dont ever modify (change,manipulate) 
      the state manually like that. always return a new one 
    
    return state.concat([action.payload.data]); // this is okay because it returns 
      an new array (state)

    return [action.payload.data, ...state]; using the spread operator, it gives u back 
      an array which starts with action.payload.data


* use propTypes to validate props on a component :
  MyComponent.propTypes= {
    prop1: React.PropTypes.array,
    prop2: React.PropTypes.func
  }

* React life-cycle functions and API calls (where should u do you API calls) :
   Component life-cycle methods : https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0
   
   APIs in React : https://hackernoon.com/where-to-integrate-api-calls-in-reactjs-componentwillmount-vs-componentdidmount-710085dc05c3
                   https://forum.freecodecamp.org/t/react-lifecycle-methods-where-do-you-make-your-api-calls/89117

* in a sample react application we declare the state in the constructor and gives it it's values inside
  one of react life-cycle function 'componentWillMount' which gets called every time the component is rerendered
  we assign the value of the state inside this function using setState method

* to set default props on a component, use the static defaultProps
  static defaultProps = {}
  now you can access whatever you define inside that object through this.props
 
* refs Attribute 


* Controlled Components are set by the state object 
  value={this.state.term}
  it's value only ever changes when the state value changes

* JSX is a preprocessor step that adds XML syntax to JavaScript. You can definitely 
  use React without JSX but JSX makes React a lot more elegant. Just like XML, JSX tags have 
  a tag name, attributes, and children.

* Jsx is a react extension that allows us to write javascript

* jsx can not be read by the browser that's why we need webpack and babel to compile it

* whenever we are accessing a variable inside jsx we wrap it in {}

* u need to include react in every file that has jsx in it, coz this jsx code :
  const searchbar = () => {return <input />;} ;
  it's converted to the following code :
  React.createElement 

* when rendering a list react requires a key for each listItem so that it can easily update them


* in react, passing callbacks is a great way to do small communication between a parent and child component.
  watch video 029
  However, be careful when passing an object method as a callback.
    we need to use bind(this) on them to keep 'this' pointing to the right context.
    another way would be to type the following in the constructor 'this.myMethod = this.myMethod.bind(this);'
    or u can just use arrow functions 


* import React, {Component} from 'react';. {Component} is the same as React.Component

**********************************************Reducers***********************************************************  

* state in react is more of a component level state, however in redux, it's more of an application level state

* Redux : a state container (a collection of all the date that describes the app).

* reducers : a function that returns a piece of the application state
  the get two arguments (state,action). 
  state argument is not the application state, it's the state the reducer is responsible for.
  reducers are only called when an action occurs 

* in your reducers directory you will normally have index.js where you will combine all reducers in the same folder into 
  on big object :
  1 - import {combineReducers} from 'redux';
  2 - const allReducers = combineReducers({});
  
  after that you should use allReducers to create a store in the main index file :
  1 - import {createStore} from 'redux';
  2 - const store = createStore(allReducers);

***********************************************Redux*****************************************************

* containers are called smart components because they have a direct access to redux

* difference between smart component and dump component :
  when exporting a dump component :
    export default UserList;
  when exporting smart component(container) :
    export default connect(mapStateToProps)(UserList); // now it's smart because it's aware of the application state


* smart components (containers) need to be the components that care the most about the state

* to connect React with Redux we use a separate library called react-redux

* Provider : makes store available to all containers (components)
  this goes in your main index.js file :
    1 - import {Provider} from 'react-redux';
    2 - ReactDom.render(
      <Provider store={store}>
        <App />
      </Provider>, document.querySelector(".container") 
    );


* mapStateToProps(state) whatever is returned will show up as props. (it bridges the redux state to react component)
  watch 042

* for mapStateToProps to work it should be call inside the connect method from 'react-redux'

* connect (mapStateToProps, mapDispatchToProps, mergeProps, options) (component);
  these parameters can be function or an object. However mapStateToProps needs to be a function

* whenever the state changes when using redux :
  1 - the container rerenders
  2 - and the object in the mapStateToProps will be assigned to the props property

* an action creator is a function that returns an action(an object), the action then is sent to all reducers
  which will normally have a switch statement to handle the action, the reducers will react to the action by 
  updating the state which will cause the mapStateToProps to run and the containers to rerenders.


* action : can also be define as any change done to your app(clicking a button, submitting a form)


* every action must have a type(always an uppercase usually string).
  an action may have a payload (more info on the action)

* to send the action to all reducers we use bindActionCreators method. 'import {bindActionCreators} from 'redux' '

* mapDispatchToProps : whatever is returned ends up as props. bindActionCreators is called from inside this method

* 5 Ways to Connect Redux Actions : (with mapDispatchToProps)
  https://blog.benestudio.co/5-ways-to-connect-redux-actions-3f56af4009c8

* 4 ways to dispatch actions with Redux
  https://blog.bam.tech/developper-news/4-ways-to-dispatch-actions-with-redux


* MiddleWares : functions that manipulate actions before they hit reducers 
  redux-promise middleware package : 
   it's going to automatically stop the action before it's sent to the reducers 
   and check whether it contains a promise or not, if it does it consumes that 
   promise and sends the date to the reducers

   notes on redux-promise :
    If it receives a promise, it will dispatch the resolved value of the promise. It will not dispatch anything if the promise rejects.
    If it receives an Flux Standard Action whose payload is a promise, it will either
      - dispatch a copy of the action with the resolved value of the promise, and set status to success.
      - dispatch a copy of the action with the rejected value of the promise, and set status to error.

    to deal with failed promise :
      https://stackoverflow.com/questions/35439019/redux-promise-with-axios-and-how-do-deal-with-errors


* third-part libraries like google-maps that don't know how to work with react, have a special 
    way of when dealing with them cause they don't understand what render() is or what jsx is
    an example of this would be the Weather application => components => google_maps.js

    however there's a new library that has been created specifically to work with react for google-maps
      here is a quick starting point : (react-google-maps)
        https://medium.com/@yelstin.fernandes/render-a-map-component-using-react-google-maps-5f7fb3e418bb
      another package : (google-map-react):
        https://hackernoon.com/implement-google-maps-in-reactjs-5bc218074689


* redux-form : watch 086 & 087
  1 - in your reducer index add the following : 
    import {reducer as formReducer} from 'redux-form'
    inside rootReducer add : form: formReducer

  2 - import the reduxForm function from 'redux-form'
    it acts like the connect function, it injects some helpers for us on the props
    lets say we have the following fields (title,categories, content)
    
  3 - we extract the handleSubmit and the fields in just one line using es6 syntax
      const {fields: {title, categories, content}, handleSubmit } = this.props
        or you can use normal javascript 
      const title = this.props.fields.title;   

  4 - reduxForm function acts exactly like connect and it can also be used to covert a 
      component to a container.
      reduxForm(formConfig, mapStateToProps, mapDispatchToProps)
        so here we can make use of the third argument to dispatch an action
        whenever the onSubmit event is fired and the form is valid (handle makes sure it's vaild)


  5 - in our form tag <form onSubmit={handleSubmit(here you pass the action you dispatched)}
  

  6 - an object containing the fields values will be sent to the action which receives it as argument
      {
        title: value,
        categories: value,
        content: value
      }

  7 - to validate you pass the validation function into the formConfig object and u define 
      the validation rules inside it 

  notice that whenever the user does any changes to the fields, redux-form sets 
  the new values on our global application state.

****************************************** React-Router ***********************************************************


* React-Router library :
    history library comes as a bounce with react-router, it just watches the url and passes new url changes to 
    react-router which updates the react components shown on the screen depending on the url
    watch 074 React Router

* setting up react-router :
    1 - import {Router, [browserHistory or hashHistory or memoryHistory] } from 'react-router';
      Router : decides what component to render when the url changes 
      browserHistory : interprets everything after the protocol 
        ex : http://www.blog.com/post/5
        browserHistory will only care about the 'post/5' part (whatever after the protocol)
      hashHistory : interprets everything after the the # 
        ex : http://www.blog.com/#post/5
      memoryHistory : doesn't use the url at all
    
    2 - define the Router component as the root component for the application 
    3 - create a file that contains the routes rules 

* when you have nested routes, the childs are passed to the root component as this.props.children

* IndexRoute : only shows up only when the path matches up the one defined by the parent.

* componentWillMount : it's a component lifecycle method, it's called when thte component is about to render on the screen for the first time
    automatically called by react.

* to link between components in react-router we use the link component that comes with it 
    import {Link} from 'react-router'; it's rendered as <a></a>

* you should avoid working with context as mush as possible except when working with react router
  context 
******************************************************************************************************















