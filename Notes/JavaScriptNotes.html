<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>


</body>

<script src="">
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get Date from the console :
    var x = prompt('what is your name ?');
    console.log(x);







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // if statement

    // any datatype that you put inside the () of an if statement gets converted to a boolean 

    if (a) { // if a is one these [undefined, null, '', 0] the statement will fail 

    }

    // some examples on the or operator 
    0 || 1                  // 1
    undefined || 'hello'    // hello
    null || 'hello'         // hello
    "" || 'hello'           // hello








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //function in Js :

    // in Js are primitive types are passed by values 
    // and all objects are by reference 

    // because functions in Js are first class functions we can do the following 
    // functions are objects (first class functions)
    function greet() {
        console.log('hi');
    }
    greet.language = 'english';
    console.log(greet);         // that would output the function itself
    console.log(greet.language);// this outputs 'english'



    // functions expression & statements hoisting 
    greet(); // works
    function greet() {
        console.log('hi');
    }

    anonymousGreet(); // this would give an undefined error (function expressions are not hoisted )
    var anonymousGreet = function () { // 
        console.log('hi');
    }
    anonymousGreet();



    // passing functions as arguments 
    function log(a) { // 'a' is the function created on the fly 
        a();
    }

    log(function () { // here we are creating a function on the fly as an arguments (we can do that coz functions are objects)
        console.log('hi');
    });



    //  automatic semicolon insertion 

    function getPerson() {

        return
        {
            firstname: 'Tony'
        }

    }
    console.log(getPerson()); // wouldn't works because of the automatic semicolon Insertions 
    // after the return statement inside the function

    function getPerson() {

        return {
            firstname: 'Tony'
        }

    }
    console.log(getPerson());




    // another way of creating function expressions (wrapping the function in () )
    (
        function (name) {

        }
    );

    // to invoke it immediately (IIFE)
    (
        function (name) {

        }
    )(myArgument);






    // Function Factories
    function makeGreeting(language) {

        return function (firstname, lastname) {

            if (language === 'en') {
                console.log('Hello ' + firstname + ' ' + lastname);
            }

            if (language === 'es') {
                console.log('Hola ' + firstname + ' ' + lastname);
            }

        }

    }

    var greetEnglish = makeGreeting('en');
    var greetSpanish = makeGreeting('es');

    greetEnglish('John', 'Doe');
    greetSpanish('John', 'Doe');

    /* In the last two lines we are using the power of closure.
    greetEnglish has access to 'en' because of closure (greetEnglish is an inner function to makeGreeting)

    This is called function Factories, and that's why we don't need function overloading in Js
    */











    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Loops in JavaScript
    // https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript

    // for of loop (es6)
    let incomes = [62000, 67000, 75000];
    for (const income of incomes) {
        console.log(income);
    }


    let fullName = "Dylan Coding God Israel";
    for (const char of fullName) {
        console.log(char);
    }

    // trying to change values of an array
    let incomes = [62000, 67000, 75000];
    for (let income of incomes) {
        income += 5000;
    }
    console.log(incomes); // won't change. it's only designed to loop through arrays not to modigy them


    // For in (with objects)
    var person = {
        firstname: 'Default',
        lastname: 'Default',
        getFullName: function () {
            return this.firstname + ' ' + this.lastname;
        }
    }

    var john = {
        firstname: 'John',
        lastname: 'Doe'
    }

    // don't do this EVER! for demo purposes only!!!
    john.__proto__ = person;

    for (var prop in john) {
        if (john.hasOwnProperty(prop)) { // the if statement makes sure that the property really
            // belongs to the object and not on its prototype. 
            console.log(prop + ': ' + john[prop]);
        }
    }


    // For in (with Arrays)

    // avoid iterating though an array with for in (it access the object properties and 
    // the prototype properties and you don't want that)
    // 062 js-weird parts








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //use strict

    // if you want your whole code to run in a strict mode, declare it at the top of the file (the first line)
    function logNewPerson() {
        "use strict"; // the function execution context now is strict but not the global context though
        var person2;
        persom2 = {};
        console.log(persom2);
    }

    var person;
    persom = {};
    console.log(persom);
    logNewPerson();








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //typeof and instanceof

    var a = 3;
    console.log(typeof a);

    var b = "Hello";
    console.log(typeof b);

    var c = {};
    console.log(typeof c);

    var d = [];
    console.log(typeof d); // weird!
    console.log(Object.prototype.toString.call(d)); // better!

    function Person(name) {
        this.name = name;
    }

    var e = new Person('Jane');
    console.log(typeof e);
    console.log(e instanceof Person);

    console.log(typeof undefined); // makes sense
    console.log(typeof null); // a bug since, like, forever...

    var z = function () { };
    console.log(typeof z);







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Arrays in Js :
    var names = ['Omar', 'moh', 'Awwad']; // this one is faster and more readable
    var names = new Array('Omar', 'moh', 'Awwad');

    names.forEach(function (current, index, array) {

    });


    //forEach accepts a call back as well
    const renderRecipe = recipe => {
        // some code
    }
    export const renderResults = recipes => {
        recipes.foreach(renderRecipe);
    }



    var newArr = names.map(function (current, index, array) { // the only difference betwenn foreach and map is that this one returns a new array
        return current;
    }); // newArr will be an array of Omar, moh, awwad


    function cal() { // returns an arrray
        const arr = [2, 4, 5, 6, 7];

        return arr.map(num => {
            return (num * 2);
        });
    }


    // reduce method https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
    // Array Reference (Properties && Methods) : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
    //                                          https://www.w3schools.com/jsref/jsref_obj_array.asp


    // prototype property for Arrays :
    Array.prototype.myUcase = function () {
        var i;
        for (i = 0; i < this.length; i++) {
            this[i] = this[i].toUpperCase();
        }
    };
    var names = ['omar', 'moh'];
    names.myUcase();


    // removing elements without leaving any gaps
    var myList = [];
    myList.push({ ololo: "ololo0" });
    myList.push({ ololo: "ololo1" });
    myList.push({ ololo: "ololo2" });
    console.log(myList);

    console.log(remove(myList, 1));


    function remove(arr, index) {
        arr.splice(index, 1);
        return arr;
    }


    // in es6 includes() replaced indexOf() which only returns either true or false 
    // includes is not supported by internet explorer 
    let numArray = [1, 2, 3, 4, 5];
    console.log(numArray.includes(2));









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sets 


    // set removes any duplicate values. exampleSet.size is 2 at this point 
    // stes are iterable (with forEach etc....) 
    const exampleSet = new Set([1, 1, 1, 1, 2, 2, 2, 2]);

    exampleSet.add(5);
    exampleSet.add(5).add(17);

    console.log(exampleSet.delete(5)); // ture or false
    console.log(exampleSet.has(2))     // true 

    console.log(exampleSet.size);      // the size is gonna be only 3 coz it removes the duplicates 
    exampleSet.clear(); // clears everythig 










    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Objects : (a variable containing an object, doesn't have a real copy of the object. it just points (reference)to it.)

    // JavaScript Objects are Mutable
    // Objects are mutable: They are addressed by reference, not by value.
    // If person is an object, the following statement will not create a copy of person:
    var x = person;
    // The object x is not a copy of person. It is person. Both x and person are the same object.


    var john = { // this way of creating objects is called object literal (the best way of creating object)
        name: 'John',
        lastName: 'Smith',
        yearOfBirth: 1990,
        job: 'teacher',
        isMarried: false
    };

    console.log(Object.values(john));
    console.log(Object.keys(john));
    console.log(john.lastName);
    console.log(john['lastName']);

    var xyz = 'job';
    console.log(john[xyz]);

    john.lastName = 'Miller';
    john['job'] = 'programmer';


    var jane = new Object();
    jane.name = 'Jane';
    jane.lastName = 'Smith';
    jane['yearOfBirth'] = 1969;
    jane['job'] = 'retired';
    jane['isMarried'] = true;

    // Object with methods :

    var john = {
        name: 'John',
        lastName: 'Smith',
        yearOfBirth: 1990,
        job: 'teacher',
        isMarried: false,
        family: ['Jane', 'Mark', 'Bob'],
        calculateAge: function () {
            this.age = 2016 - this.yearOfBirth; // this creates an Age property when the function is invoked
        }
    };
    john.calculateAge();


    var mike = {
        yearOfBirth: 1950,
        calculateAge: function () {
            this.age = 2016 - this.yearOfBirth; // this creates an Age property when the function is invoked
        }
    };
    mike.calculateAge();


    // objects inside of objects 
    var person = new Object();

    person.address = new Object();
    person.address.city = 'ny';
    person.address.state = 'sdf';

    // object literal way 
    var person = {
        firstName: 'omar',
        lastName: 'awwad',
        address: {
            street: 'sdfsd',
            city: 'sdf',
        }
    };










    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Execution Contexts : what section No:3

    /* Section No:3 summary 
        Our code runs inside Js Engine, each browser has it's own Js Engine.
        Inside the Js Engine there is a parser which reads our code line by line and checks the syntax.
        The parser converts our code to a data structure called abstract syntax tree which is later converted to machine language.
        Js code need an environment (Execution Context) to run.
        Execution Context : wrapper which stores variables and in which the code is evaluated and executed.
        The global context is the default execution context.

        Global code that is not inside any function, it's associated with the global object, that's the widow object in the browser
        in other words, everything we declare in the global object automatically gets attached to the window object
        lastName === window.lastName   
        
        Each time we call a function it gets its own execution context added on top of the execution stack.

        Execution context has 3 properties :
            Variable Object(vo) :
                - function arguments
                - variable declaration 
                - function declaration 

            scope chain :  
                - the current vo
                - VOs of all its parents 

            This variable 

        When we call a function an execution context is created and it goes through 2 phases :
            1 - Creation phase :
                - creation of VO :
                    - argument object is created containing all the arguments passed into the function
                    - code is scanned for function declarations, for each function a property is created in the VO pointing to the function (Hoisting)
                    - code is scanned for variable declaration for each variable a property is created in VO and set to undefined (Hoisting)
                    - Both variables and functions are hoisted (available before the execution phase starts)
                    - Functions are already defined before the execution phase. However variables are set to undefined until the execution phase

                - creation of scope chain : 
                    - a new scope is created with every new function(in Js creating functions is the only way of creating new scopes)
                    - lexical scoping : an inner functions get access to the outer functions scope.
                
                - determine value of 'this' :
                    - the value of the 'this' keyword is only determine when the function gets called 

            2- execution phase :
                the code is executed line by line.
    */

    /* 
    If your code is not inside a function it gets attached to the global object
    
    Each execution context has a reference to the outer environment (scope chain)
    where it searches for variables that don't exist in the current scope
 
    any event that you have gets added to the event queue inside the browser, However Js would only handle the 
    event when the the execution stack is empty, so if you have functions that take time to run they might
    interrupt events being handled.

    Asynchronous callbacks are possible in Js, However the Asynchronous part happens outside the Js Engine
    itself (ex: Event Queue) but js Engine itself is not Asynchronous   
    
    */









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Hoisting in JavaScript : the main takeaway is that you can use a function in js before u actually create it
    // what section No:3

    calculateAge(1965); // this would work because functions statements and variables in Js are hoisted
    function calculateAge(year) {
        console.log(2016 - year);
    }

    retirement(1956); // wouldn't work coz this is function expression
    var retirement = function (year) {
        console.log(65 - (2016 - year));
    }

    console.log(age); // this would give you undefined coz in javascript variables are hoisted and set to undefined before the execution phase 
    var age = 23;



    if (false) {
        var example = 5;
    }
    console.log(example); // this would be undefined  



    if (false) {
        let example = 5;
    }
    console.log(example); // this would be through an error, let and const aren't hoisted 



    const example = {
        firstName: 'omar'
    };
    example.firstName = 'Dylan'; // even though example is a const, we still can modify the content (the same applies for object)
    console.log(example);



    const example = [];
    example = 3; // this would through an error, we can't change the datatype 
    console.log(example);



    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Scoping :
    // First scoping example
    var a = 'Hello!';
    first();

    function first() {
        var b = 'Hi!';
        second();

        function second() {
            var c = 'Hey!';
            console.log(a + b + c); // this will print out Hello!Hi!Hey!
        }
    }

    // Example to show the difference between execution stack and scope chain
    var a = 'Hello!';
    first();

    function first() {
        var b = 'Hi!';
        second();

        function second() {
            var c = 'Hey!';
            third(); // second function has access to the third function because of scoping  
        }
    }

    function third() {
        var d = 'John';
        //console.log(c); will give you an error
        console.log(a + d); // it only has access to these variables
    }









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This KeyWord :
    // 1 - each execution context has 'this' keyword
    // 2 - in a Regular Function Call : points at the global object (the window object)
    // 3 - in a Method Call : points to the object calling the method
    // 4 - this keyword is only assigned a value when the function where it's defined is called 
    // 5 - arrow functions don't have their own this keyword. (search for Arrow functions 2 lexical this keyword in this file)  
    // 6 - this keyword in object methods set as callbacks :
    // https://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-inside-a-callback

    console.log(this); // this points to the window
    calculateAge(1985);

    function calculateAge(year) {
        console.log(2016 - year);
        console.log(this); // this points to the window coz it's a regular function call
    }

    var john = {
        name: 'John',
        yearOfBirth: 1990,
        calculateAge: function () {
            console.log(this); // points to the john object coz it's a method call
            console.log(2016 - this.yearOfBirth);

            function innerFunction() { // innerFunction is not a method.
                console.log(this); // careful, this also points to the window object coz it's still a regular function call not a method
            }
            innerFunction(); // function call
        }
    }

    john.calculateAge(); // method call


    var mike = {
        name: 'Mike',
        yearOfBirth: 1984
    };


    mike.calculateAge = john.calculateAge; // this is method borrowing (without the parenthesis, coz we are not calling any methods)
    mike.calculateAge();



    // some experiments with This in function constructor and normal object :

    const box68 = {
        color: 'green',
        position: 1,
        getThis: this,

        displayThis: function () {
            console.log(this.getThis)
        }
    }
    box68.displayThis(); // widow object


    const box69 = {
        color: 'green',
        position: 1,
        getThis: this,

        displayThis: function () {
            console.log(this)
        }
    }
    box69.displayThis(); // box69 object



    const box74 = function (color, position, ) {
        this.color = color;
        this.position = position;
        thisval = this;
        this.displayThis = function () {
            console.log(thisval)
        }
    }
    let b = new box74("green", 9);
    b.displayThis(); // box74 object = b



    const box76 = function (color, position, ) {
        this.color = color;
        this.position = position;
        this.displayThis = () => {
            console.log(this.color)
        } // arrow functions donâ€™t have this
    }
    let d = new box76("green", 9);
    d.displayThis(); // green


    const box77 = function (color, position, ) {
        this.color = color;
        this.position = position;
        console.log(this);
    }
    let v = new box77("green", 9); // box77 object = v







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // DOM manipulation :
    // very Important link :    https://www.sitepoint.com/dom-manipulation-vanilla-javascript-no-jquery/
    // Reference        :       https://www.w3schools.com/jsref/dom_obj_document.asp
    // Events Reference :       https://developer.mozilla.org/en-US/docs/Web/Events
    // Element Object   :       https://www.w3schools.com/jsref/dom_obj_all.asp

    // useful like for Dom manipulation
    // https://github.com/nefe/You-Dont-Need-jQuery#dom-manipulation

    // important events :
    // hashchange :  https://developer.mozilla.org/en-US/docs/Web/Events/hashchange
    // load       :  https://developer.mozilla.org/en-US/docs/Web/Events/load


    // how to add the same event listener to different events 
    ['hashchange', 'load'].forEach(event => window.addEventListener(event, () => { }))

    /*                          
    You can only access style properties in Javascript that have been set via Javascript or the style attr (inline styling).

    To access the elements current style you should fetch the computed style of the element. 
        var el = document.getElementById('mydiv');
        var comp = el.currentStyle || getComputedStyle(el,null);
        alert(comp.backgroundColor)
    */


    /* 
     The difference between Event.target and Event.currentTarget
     
     // http://joequery.me/code/event-target-vs-event-currenttarget-30-seconds/
     
     currentTarget: will never change (whatever before the dot)
     target: what you actually click on will never change
 
     
    */


    // console.dir is the way to see all the properties of a specified JavaScript object in console 
    // by which the developer can easily get the properties of the object.
    console.log(document.location);


    // EXAMINE THE DOCUMENT OBJECT //
    console.dir(document);
    console.log(document.domain);
    console.log(document.URL);
    console.log(document.title);
    document.title = 123;
    console.log(document.doctype);
    console.log(document.head);
    console.log(document.body);
    console.log(document.all); // gives you an array-like object of the document elements 
    console.log(document.all[10]);
    document.all[10].textContent = 'Hello';
    console.log(document.forms); // gives you an array-like object of all the forms that you have
    console.log(document.forms[0]);
    console.log(document.links);
    console.log(document.images);

    // GETELEMENTBYID //
    console.log(document.getElementById('header-title'));
    var headerTitle = document.getElementById('header-title');
    var header = document.getElementById('main-header');
    console.log(headerTitle);
    headerTitle.textContent = 'Hello'; // textContent doesn't respect the styling of an element
    headerTitle.innerText = 'Goodbye'; // innerText property respects the styling of elements
    console.log(headerTitle.innerText);
    headerTitle.innerHTML = '<h3>Hello</h3>';
    header.style.borderBottom = 'solid 3px #000';

    // GETELEMENTSBYCLASSNAME //
    var items = document.getElementsByClassName('list-group-item');
    console.log(items);
    console.log(items[1]);
    items[1].textContent = 'Hello 2';
    items[1].style.fontWeight = 'bold';
    items[1].style.backgroundColor = 'yellow';

    for (var i = 0; i < items.length; i++) {
        items[i].style.backgroundColor = '#f4f4f4';
    }

    // GETELEMENTSBYTAGNAME //
    var li = document.getElementsByTagName('li'); // gives you all the li elements in the document
    console.log(li);
    console.log(li[1]);
    li[1].textContent = 'Hello 2';
    li[1].style.fontWeight = 'bold';
    li[1].style.backgroundColor = 'yellow';

    // QUERYSELECTOR //
    var header = document.querySelector('#main-header');
    header.style.borderBottom = 'solid 4px #ccc';

    var input = document.querySelector('input');
    input.value = 'Hello World'

    var submit = document.querySelector('input[type="submit"]');
    submit.value = "SEND"

    var item = document.querySelector('.list-group-item');
    item.style.color = 'red';

    var lastItem = document.querySelector('.list-group-item:last-child');
    lastItem.style.color = 'blue';

    var secondItem = document.querySelector('.list-group-item:nth-child(2)');
    secondItem.style.color = 'coral';


    // QUERYSELECTORALL //
    var titles = document.querySelectorAll('.title'); // returns a node list

    console.log(titles);
    titles[0].textContent = 'Hello';

    var odd = document.querySelectorAll('li:nth-child(odd)');
    var even = document.querySelectorAll('li:nth-child(even)');

    for (var i = 0; i < odd.length; i++) {
        odd[i].style.backgroundColor = '#f4f4f4';
        even[i].style.backgroundColor = '#ccc';
    }


    // TRAVERSING THE DOM //
    var itemList = document.querySelector('#items');

    // parentNode
    console.log(itemList.parentNode);
    itemList.parentNode.style.backgroundColor = '#f4f4f4';
    console.log(itemList.parentNode.parentNode.parentNode);


    // parentElement
    console.log(itemList.parentElement);
    itemList.parentElement.style.backgroundColor = '#f4f4f4';
    console.log(itemList.parentElement.parentElement.parentElement);


    // childNodes (not recommended. use children instead) 
    console.log(itemList.childNodes);
    // the list that is returned by childNodes includes any white spaces or line breaks you have
    // as elements of the list 


    // children
    console.log(itemList.children);
    console.log(itemList.children[1]);
    itemList.children[1].style.backgroundColor = 'yellow';


    // FirstChild and LastChild (not recommended. use FirstElementChild and lastElementChild instead)
    console.log(itemList.firstChild);
    console.log(itemList.lastChild);
    // it does the exact same thing as the childNodes


    // firstElementChild and lastElementChild
    console.log(itemList.firstElementChild);
    itemList.firstElementChild.textContent = 'Hello 1';

    console.log(itemList.lastElementChild);
    itemList.lastElementChild.textContent = 'Hello 4';


    // nextSibling (not recommended use nextElementSibling instead)
    console.log(itemList.nextSibling);

    // nextElementSibling
    console.log(itemList.nextElementSibling);

    // previousSibling (not recommended use previousElementSibling instead)
    console.log(itemList.previousSibling);

    // previousElementSibling
    console.log(itemList.previousElementSibling); itemList.previousElementSibling.style.color = 'green';


    // createElement

    var newDiv = document.createElement('div');

    // Add class
    newDiv.className = 'hello';

    // Add id
    newDiv.id = 'hello1';

    // Add attr
    newDiv.setAttribute('title', 'Hello Div');

    // Create text node
    var newDivText = document.createTextNode('Hello World');

    // Add text to div
    newDiv.appendChild(newDivText);

    var container = document.querySelector('header .container');
    var h1 = document.querySelector('header h1');

    console.log(newDiv);

    newDiv.style.fontSize = '30px';

    container.insertBefore(newDiv, h1);



    // EVENTS //

    var button = document.getElementById('button').addEventListener('click', buttonClick);

    function buttonClick(e) {

        console.log('Button clicked');
        document.getElementById('header-title').textContent = 'Changed';
        document.querySelector('#main').style.backgroundColor = '#f4f4f4';
        console.log(e);

        console.log(e.target);
        console.log(e.target.id);
        console.log(e.target.className);
        console.log(e.target.classList);
        var output = document.getElementById('output');
        output.innerHTML = '<h3>' + e.target.id + '</h3>';

        console.log(e.type);

        console.log(e.clientX); // from the browser 
        console.log(e.clientY);

        console.log(e.offsetX); // from the element itself
        console.log(e.offsetY);

        console.log(e.altKey); // if the key was held while the event happened, it returns true
        console.log(e.ctrlKey);
        console.log(e.shiftKey);
    }


    // handle a submit event of a form :
    form.addEventListener('submit', myCallback);
    function myCallback(e) {
        e.preventDefault();
        // you code codes here
    }


    // important events to go over 
    /* 
        click
        dblclick
        mousedown
        mouseup
        mouseenter
        mouseleave
        mouseover
        mouseout
        mousemove

        keydown
        keyup
        keypress
        focus
        blur
        cut
        paste
        input // it listens for keystrokes, cut and paste events on a particular input element. it also can be used with select elements            
        change
    
    */




    // HOW TO GET THE CLASSES OF ELEMENTS :

    document.getElementById('el').className // returns a string
    document.getElementById('el').classList // returns a list 
    // you can perform some method on the classList 
    // https://www.w3schools.com/jsref/prop_element_classlist.asp


    // to get the height of an element's content :
    Element.scrollHeight // read-only property





    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Inheritance : (Js is a prototype-based language)
    // the prototype property of an object is where we put methods and properties
    // that we want other objects to inherit.

    // few important notes on inheritance in Js :
    // 1. every js object has a prototype property which makes inheritance possible
    // 2. when a certain method or property is called, the search starts in the
    // object itself, and if it's not there it moves to the object's prototype.

    // article on inheritance and prototypes in Js
    // https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript


    // in and delete operator :
    //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in
    //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Function constructor (it's only a template (a class))
    // the methods that you have inside the function constructor are invoked only through an object.

    /* 
        any function constructor returns the new object created by default 

        it's best practice to only add properties inside the function constructor and add 
        method using the 'prototype' property of the function constructor (to not duplicate methods, just have one available to all the instances)

        each function created in Js gets a property called 'prototype' which is only used when the 
        function is being used as a function constructor, it starts off empty.

        it's worth noting that the 'prototype' property is not the prototype of the function constructor itself
        ,but it's the prototype of every and each object created using that function constructor 

        prototype vs __proto__ 
            The prototype is a property on a constructor function that sets what will become the __proto__ property 
            on the constructed object.

            __proto__ is the actual object that is used in the lookup chain to resolve methods, etc.  prototype is 
            the object that is used to build __proto__ when you create an object with new:

            ( new Foo ).__proto__ === Foo.prototype;
            ( new Foo ).prototype === undefined;

            prototype is only available on functions since they are derived from Function, Function, and Object 
            but in anything else it is not. However, __proto__ is available everywhere.
    */


    var john = {
        name: 'John',
        yearOfBirth: 1990,
        job: 'teacher'
    };

    var Person = function (name, yearOfBirth, job) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.job = job;
    }

    Person.prototype.calculateAge = function () { // this method is not attached to the objects created but it can be inherited by them
        console.log(2016 - this.yearOfBirth);
    };

    Person.prototype.lastName = 'Smith';

    var john = new Person('John', 1990, 'teacher'); // the new keyword creates
    // a new empty object and have the this keyword point at the object itself
    // rather than the global context (notice that calling Person without the new
    // keyword would have the this keyword point at the global context)
    var jane = new Person('Jane', 1969, 'designer');
    var mark = new Person('Mark', 1948, 'retired');

    john.calculateAge();
    jane.calculateAge();
    mark.calculateAge();

    console.log(john.lastName);
    console.log(jane.lastName);
    console.log(mark.lastName);


    // another example :

    function Vehicle(make, model, color) {
        this.make = make,
            this.model = model,
            this.color = color,
            this.getName = function () {
                return this.make + " " + this.model;
            }
    }

    let car = new Vehicle("Toyota", "Corolla", "Black");
    let car2 = new Vehicle("Honda", "Civic", "White");

    car2.year = "2012"; // only added to car2 object. doesn't exist inside Vehicle

    console.log(car2.year);// 2012
    console.log(car.year); // undefined 
    console.log(Vehicle.year); // undefined

    // to add the year property to the constructor function use the prototype property
    Vehicle.prototype.year = "0";
    console.log(car.year);// 0
    console.log(car.__proto__); // Vehicle {year: '0'}
    console.log(Object.getPrototypeOf(car)); // Vehicle {year: '0'}




    // Inheritance 

    var person = {
        firstname: 'Default',
        lastname: 'Default',
        getFullName: function () {
            return this.firstname + ' ' + this.lastname;
        }
    }

    var john = {
        firstname: 'John',
        lastname: 'Doe'
    }

    // don't do this EVER! for demo purposes only!!!
    john.__proto__ = person;
    console.log(john.getFullName()); // john Doe

    var jane = {
        firstname: 'Jane'
    }

    // don't do this EVER! for demo purposes only!!!
    jane.__proto__ = person;
    console.log(jane.getFullName()); // jane Default




    /* object.create() and prototypal inheritance 

    all modern browsers have object.create built-in.
    object.create(baseObj) creates an new empty object and sets its prototype to baseObj prototype
    then we can we can modify this new prototype by overriding or adding new stuff to it

    */
    var person = {
        firstname: 'Default',
        lastname: 'Default',
        greet: function () {
            return 'Hi ' + this.firstname;
        }
    }

    var john = Object.create(person);
    john.firstname = 'John';
    john.lastname = 'Doe';
    console.log(john);




    /* Classical inheritance with Object.create()
        we also can do that with function constructors and it's called classical inheritance 
    */

    // Shape - superclass
    function Shape() {
        this.x = 0;
        this.y = 0;
    }

    // superclass method
    Shape.prototype.move = function (x, y) {
        this.x += x;
        this.y += y;
        console.info('Shape moved.');
    };

    // Rectangle - subclass
    function Rectangle() {
        Shape.call(this); // call super constructor.
    }

    // subclass extends superclass
    Rectangle.prototype = Object.create(Shape.prototype);
    Rectangle.prototype.constructor = Rectangle;

    var rect = new Rectangle();

    console.log('Is rect an instance of Rectangle?',
        rect instanceof Rectangle); // true
    console.log('Is rect an instance of Shape?',
        rect instanceof Shape); // true
    rect.move(1, 1); // Outputs, 'Shape moved.'



    /* If you wish to inherit from multiple objects, then mixins are a possibility. 
          Object.assign copies properties from the OtherSuperClass prototype to 
          the MyClass prototype
    */
    function MyClass() {
        SuperClass.call(this);
        OtherSuperClass.call(this);
    }

    // inherit one class
    MyClass.prototype = Object.create(SuperClass.prototype);
    // mixin another
    Object.assign(MyClass.prototype, OtherSuperClass.prototype);
    // re-assign constructor
    MyClass.prototype.constructor = MyClass;

    MyClass.prototype.myMethod = function () {
        // do a thing
    };





    // another example of Classical inheritance with Object.create()

    function Book(title, author, year) {
        this.title = title;
        this.author = author;
        this.year = year;
    }

    Book.prototype.getSummary = function () {
        return `${this.title} was written by ${this.author}
      in${this.year}`;
    };

    // magazine Constructor
    function Magazine(title, author, year, month) {
        Book.call(this, title, author, year);
        this.month = month;
    }

    Magazine.prototype.sayHi = function () {
        console.log("hi");
    };

    // Instantiate Magazine object
    const mg1 = new Magazine('Mag one', 'john doe', '2018', 'Jan');
    console.log(mg1.sayHi());
    console.log(mg1.getSummary()); // you get a typeError
    // mg1 has no access to Book.prototype, therefore can't access getSummery method
    // just because Magazine inherits from Book, doesn't mean Magazine instances have access to Book.prototype.

    // to solve this replace the above code (starting from line:894) with the following :
    Magazine.prototype = Object.create(Book.prototype); // we're create a new object using object.create which accepts an object that it's prototype is used
    // for the newly created object which gets assigned to Magazine.prototype object
    Magazine.prototype.constructor = Magazine; // here we are setting back the right constructor (the code still works without this line)
    const mg1 = new Magazine('Mag one', 'john doe', '2018', 'Jan');
    console.log(mg1.getSummary()); // now it works just



    // Object.create (setting the prototype manually)
    const bookProtos = { // here we are creating an object to use its prototype as the base for new objects 
        getSummury: function () {
            return `${this.title} was written by ${this.author} in ${this.year}`;
        },
        getAge: function () {
            const years = new Date().getFullYear() - this.year;
            return `${this.title} is ${year} years old;`
        }
    };

    // now we create the object
    const book1 = Object.create(bookProtos);
    book1.title = 'book one';
    book1.author = 'john doe';

    // another way of creating the same object 
    const book1 = Object.create(bookProtos, {
        title: { value: 'book one' },
        author: { value: 'john doe' }
    });




    // modifying built-in prototypes :
    String.prototype.isLengthGreaterThan = function (limit) { // adding it to all strings 
        return this.length > limit;
    }

    console.log("John".isLengthGreaterThan(3));

    Number.prototype.isPositive = function () {
        return this > 0;
    }

    console.log(new Number(3).isPositive());






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Object.Create (a different way of creating an object)
    // it allows as to set the prototype manually for the newly created object
    var personProto = {
        calculateAge: function () {
            console.log(2016 - this.yearOfBirth);
        }
    };

    var john = Object.create(personProto);
    john.name = 'John';
    john.yearOfBirth = 1990;
    john.job = 'teacher';

    var jane = Object.create(personProto, {
        name: {
            value: 'Jane'
        },
        yearOfBirth: {
            value: 1969
        },
        job: {
            value: 'designer'
        }
    });








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functional Programming 
    // try not to mutate data with functions programming 
    function mapForEach(arr, fn) {

        var newArr = [];
        for (var i = 0; i < arr.length; i++) {
            newArr.push(
                fn(arr[i])
            )
        };

        return newArr;
    }

    var arr1 = [1, 2, 3];

    var arr2 = mapForEach(arr1, function (item) {
        return item * 2;
    });
    console.log(arr2);


    var checkPastLimit = function (limiter, item) {
        return item > limiter;
    }
    var arr4 = mapForEach(arr1, checkPastLimit.bind(this, 1));
    console.log(arr4);


    var checkPastLimitSimplified = function (limiter) {
        return function (limiter, item) {
            return item > limiter;
        }.bind(this, limiter);
    };

    var arr5 = mapForEach(arr1, checkPastLimitSimplified(1));
    console.log(arr5);







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Primitives vs objects

    // Primitives
    var a = 23;
    var b = a;
    a = 46;
    console.log(a); // 46
    console.log(b); // 23

    // Objects
    var obj1 = {
        name: 'John',
        age: 26
    };
    var obj2 = obj1;
    obj1.age = 30;
    console.log(obj1.age); // 30 (Objects are mutable: They are addressed by reference)
    console.log(obj2.age); // 30

    // Functions
    var age = 27;
    var obj = {
        name: 'Jonas',
        city: 'Lisbon'
    };

    function change(a, b) {
        a = 30;
        b.city = 'San Francisco';
    }

    change(age, obj);

    console.log(age); // 27
    console.log(obj.city); // San Francisco





    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions :
    // Notes :
    // 1. are instances of the object type, therefore they behave like any other object
    // 2. we can pass a function as an argument to another function
    // 3. we can return a function from another function

    var years = [1990, 1965, 1937, 2005, 1998];

    function arrayCalc(arr, fn) {
        var arrRes = [];
        for (var i = 0; i < arr.length; i++) {
            arrRes.push(fn(arr[i]));
        }
        return arrRes;
    }

    function calculateAge(el) {
        return 2016 - el;
    }

    function isFullAge(el) {
        return el >= 18;
    }

    function maxHeartRate(el) {
        if (el >= 18 && el <= 81) {
            return Math.round(206.9 - (0.67 * el));
        } else {
            return -1;
        }
    }


    var ages = arrayCalc(years, calculateAge); // we don't use parentheses (coz, it's a callback function)
    var fullAges = arrayCalc(ages, isFullAge);
    var rates = arrayCalc(ages, maxHeartRate);

    console.log(ages);
    console.log(rates);




    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Functions returning functions

    function interviewQuestion(job) {
        if (job === 'designer') {
            return function (name) {
                console.log(name + ', can you please explain what UX design is?');
            }
        } else if (job === 'teacher') {
            return function (name) {
                console.log('What subject do you teach, ' + name + '?');
            }
        } else {
            return function (name) {
                console.log('Hello ' + name + ', what do you do?');
            }
        }
    }

    var teacherQuestion = interviewQuestion('teacher'); // the right part will return the anonymous function
    var designerQuestion = interviewQuestion('designer'); // and then we store it in the variable on the left and invoke it with a param


    teacherQuestion('John');
    designerQuestion('John');
    designerQuestion('jane');
    designerQuestion('Mark');
    designerQuestion('Mike');

    // instead of having to store the anonymous function in a variable and then invoke it
    // we can just invoke it right away once it's returned
    interviewQuestion('teacher')('Mark');




    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: IIFE

    function game() {
        var score = Math.random() * 10;
        console.log(score >= 5);
    }
    game();


    (function () { // IIFE called immediately and only only time
        var score = Math.random() * 10;
        console.log(score >= 5);
    })();
    //console.log(score); this would through an error, score is not accessible outside the function 


    (function (goodLuck) {
        var score = Math.random() * 10;
        console.log(score >= 5 - goodLuck);
    })(5);







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Closures : an inner function has always access to the variables
    // and parameters of its outer function, even after the outer function has returned


    function retirement(retirementAge) {
        var a = ' years left until retirement.';
        return function (yearOfBirth) {
            var age = 2016 - yearOfBirth;
            console.log((retirementAge - age) + a);
        }
    }

    var retirementUS = retirement(66);
    var retirementGermany = retirement(65);
    var retirementIceland = retirement(67);

    retirementGermany(1990);
    retirementUS(1990);
    retirementIceland(1990);

    //retirement(66)(1990);


    function interviewQuestion(job) {
        return function (name) {
            if (job === 'designer') {
                console.log(name + ', can you please explain what UX design is?');
            } else if (job === 'teacher') {
                console.log('What subject do you teach, ' + name + '?');
            } else {
                console.log('Hello ' + name + ', what do you do?');
            }
        }
    }

    interviewQuestion('teacher')('John');

    // how to control data access using the power of closures, this how you create a module (model - view - controller)
    // how to return an object ?
    // budgetController module
    var budgetController = (function () {
        var x = 23;
        var add = function (a) {
            return x + a;

        }
        return { // we are returning an object here
            publicTest: function () { // this function is public because it's being return
                console.log(x); // but the x and add function are private to that scope
            },
            secMethod: function () {
                // has access to all the external variables
            }
        }
    })();

    budgetController.publicTest(); // budgetController is an object that is returned by the IIFE
    budgetController.x; // won't work, this object only has the publicTest and secMethod methods



    /* ************************************* */

    function buildFunctions() {

        var arr = [];

        for (var i = 0; i < 3; i++) {

            arr.push(
                function () {
                    console.log(i);
                }
            )

        }

        return arr;
    }

    var fs = buildFunctions();

    fs[0](); // 3
    fs[1](); // 3
    fs[2](); // 3

    /* ************************************* */

    function buildFunctions2() {

        var arr = [];

        for (var i = 0; i < 3; i++) {
            arr.push(
                (function (j) { // using the power of scope chain (create a parent scope by creating a new function)
                    return function () {
                        console.log(j);
                    }
                }(i))
            )

        }

        return arr;
    }

    var fs2 = buildFunctions2();

    fs2[0](); // 0
    fs2[1](); // 1
    fs2[2](); // 2


    /* ************************************* */

    function buildFunctions() {

        var arr = [];

        for (var i = 0; i < 3; i++) {
            let j = i; // explanation of why this works is below 
            arr.push(
                function () {
                    console.log(j);
                }
            )

        }


        return arr;
    }

    var fs = buildFunctions();

    fs[0](); // 0
    fs[1](); // 1
    fs[2](); // 2

    /* why does let works and not var in this example ?

     let is block-scoped which means that with each iteration of the for loop we are creating a new 'j' 
     variable different than the one before it.
     So we end up with three different 'j' variables not overriding each other.

     However, with var keyword it's different, since var is function-scoped, we override the same 'j' with
     each iteration.
     That happens because 'j' is function-scoped and available to us within each iteration
    */













    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Bind, call and apply

    var john = {
        name: 'John',
        age: 26,
        job: 'teacher',
        presentation: function (style, timeOfDay) {
            if (style === 'formal') {
                console.log('Good ' + timeOfDay + ', Ladies and gentlemen! I\'m ' + this.name + ', I\'m a ' +
                    this.job + ' and I\'m ' + this.age + ' years old.');
            } else if (style === 'friendly') {
                console.log('Hey! What\'s up? I\'m ' + this.name + ', I\'m a ' + this.job + ' and I\'m ' + this
                    .age + ' years old. Have a nice ' + timeOfDay + '.');
            }
        }
    };

    var emily = {
        name: 'Emily',
        age: 35,
        job: 'designer'
    };

    john.presentation('formal', 'morning');

    john.presentation.call(emily, 'friendly', 'afternoon'); // method borrowing

    //john.presentation.apply(emily, ['friendly', 'afternoon']); // apply is the same but it sends an array as a second param

    var johnFriendly = john.presentation.bind(john, 'friendly');
    //bind is similar to 'call' function the difference is it does not invoke the function immediately
    // instead it generates a copy and stores it.
    // it allows you to pre-set some params (this is called carrying )


    johnFriendly('morning');
    johnFriendly('night');

    var emilyFormal = john.presentation.bind(emily, 'formal');
    emilyFormal('afternoon');


    // Another cool example
    var years = [1990, 1965, 1937, 2005, 1998];

    function arrayCalc(arr, fn) {
        var arrRes = [];
        for (var i = 0; i < arr.length; i++) {
            arrRes.push(fn(arr[i]));
        }
        return arrRes;
    }

    function calculateAge(el) {
        return 2016 - el;
    }

    function isFullAge(limit, el) {
        return el >= limit;
    }

    var ages = arrayCalc(years, calculateAge);
    var fullJapan = arrayCalc(ages, isFullAge.bind(this, 20)); // you used the bind function on
    // 'isFullAge' function to create a copy of it with pre-set arguments
    console.log(ages);
    console.log(fullJapan);


    // Using an object in an array-like fashion
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push
    var obj = {


        addElem: function addElem(elem) {
            // obj.length is automatically incremented 
            // every time an element is added.
            [].push.call(this, elem);
        }
    };

    // Let's add some empty objects just to illustrate.
    obj.addElem({});
    obj.addElem({});
    console.log(obj.length); //  2



    /* Every function in Js gets access to (bind, call and apply)

    bind : creates a copy of the function, lets you decide what the this variable should be 
        when the execution context is created

    call : executes the function, unlike bind it doesn't create a copy of it
        call(this, arg...)

    apply : is the exact same thing as call, the only difference is that it takes an array of args
        apply(this, [] )
    */

    var person = {
        firstname: 'John',
        lastname: 'Doe',
        getFullName: function () {

            var fullname = this.firstname + ' ' + this.lastname;
            return fullname;

        }
    }

        (function (lang1, lang2) { // wrapping the function into () tricks the parser into 
            // believing it's a function expression (anonymous function expression)
            console.log('Logged: ' + this.getFullName());
            console.log('Arguments: ' + lang1 + ' ' + lang2);
            console.log('-----------');

        }).apply(person, ['es', 'en']);


    // applications of bind, apply and call :

    // 1- function borrowing
    var person2 = {
        firstname: 'Jane',
        lastname: 'Doe'
    }

    console.log(person.getFullName.apply(person2));


    // 2- function currying (predefined parameters)
    function multiply(a, b) {
        return a * b;
    }
    var multipleByTwo = multiply.bind(this, 2); // this is possible because bind creates a copy
    console.log(multipleByTwo(4));

    var multipleByThree = multiply.bind(this, 3);
    console.log(multipleByThree(4));








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Event bubbling and Event Delegation

    // bubbling     : the event bubbles up inside the Dom tree
    // Delegation   : Using bubbling to place the event handler on the parent instead of the target element
    // if you have a list of items to be added to your site, instead of attaching click event on each list item
    // you can attach the event on the list itself and make use of the event delegation
    // on your event handler function you always have an access to the event as a param and therefore you can
    // get the target element that fired up the event like that "event.target"
    // if you want to reach the parent of the target element you can do this :
    event.target.parentNode // you can repeat parentNode multiple times
    // you may need to use the closest method with target property
    event.target.closest('.btn-class');
    // or
    event.target.matches('btn', 'btn *'); // this matches either btn or any child of btn








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ES6

    // Lecture: let and const
    // variables declared with var are function-scope
    // variables declared with let and const are block-scope

    // ES5
    var name5 = 'Jane Smith';
    var age5 = 23;
    name5 = 'Jane Miller'; // name5 will be 'Jane Smith'
    console.log(name5);

    // ES6
    const name6 = 'Jane Smith';
    let age6 = 23;
    name6 = 'Jane Miller'; // name6 cannot be changed
    console.log(name6);


    // ES5
    function driversLicence5(passedTest) {

        if (passedTest) {
            console.log(firstName); // will be undefined coz in an execution context all vars are hoisted
            var firstName = 'John';
            var yearOfBirth = 1990;
        }


        console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.'); // this will work coz variables declared with var are function-scope
    }

    driversLicence5(true);


    // ES6
    function driversLicence6(passedTest) {

        if (passedTest) {
            let firstName = 'John';
            const yearOfBirth = 1990;

        }

        console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.'); // this won't work coz variables declared with let and const are block-scope. (aren't available outside the if block)
    }

    driversLicence6(true);


    // this is a workaround for this problem (declare them in the function scope)
    function driversLicence6(passedTest) {

        //console.log(firstName); // will not work in ES6 even though it's hoisted
        let firstName;
        const yearOfBirth = 1990; // constants have to be initialized on the same line the were declared

        if (passedTest) {
            firstName = 'John';
        }

        console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.'); // this won't work coz variables declared with let and const are block-scope
    }

    driversLicence6(true);



    // ES5
    var i = 23;

    for (var i = 0; i < 5; i++) {
        console.log(i); // this will print (0 1 2 3 4 )
    }

    console.log(i); // this will print (5)


    // ES6
    let i = 23;

    for (let i = 0; i < 5; i++) {
        console.log(i); // this will print (0 1 2 3 4 )
    }

    console.log(i); // this will print (23)












    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Import & Export Es6 :
    https: //www.youtube.com/watch?v=Jqn_wjkSZwo
    //    1 - https://medium.com/@thejasonfile/a-simple-intro-to-javascript-imports-and-exports-389dd53c3fac
    //    2 - https://hackernoon.com/import-export-default-require-commandjs-javascript-nodejs-es6-vs-cheatsheet-different-tutorial-example-5a321738b50f

    import './loadImage.js'; // suppose that loadImage only contains some code that needs to run (ex: loading an image)











    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Blocks and IIFEs


    // in ES6 we don't need to use IIFEs to achieve data privacy we can just create blocks and use the keyword let instead of var
    {
        const a = 1;
        let b = 2;
        var c = 3;
    }

    console.log(a + b); // error
    console.log(c); // c is accessible


    // ES5     this is the old way of achieving data privacy with IIFEs in ES5
    (function () {
        var c = 3;
    })();

    console.log(c);









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Strings & template literal


    let firstName = 'John';
    let lastName = 'Smith';
    const yearOfBirth = 1990;

    function calcAge(year) {
        return 2016 - year;
    }

    // ES5
    console.log('This is ' + firstName + ' ' + lastName + '. He was born in ' + yearOfBirth + '. Today, he is ' +
        calcAge(yearOfBirth) + ' years old.');

    // ES6
    console.log(
        `This is ${firstName} ${lastName}. He was born in ${yearOfBirth}. Today, he is ${calcAge(yearOfBirth)} years old.`
    ); // this is template literals using

    // template literals allow multi-line strings
    let example = `${word1}
    ${word2}
    `;




    const n = `${firstName} ${lastName}`;
    console.log(n.startsWith('j'));
    console.log(n.endsWith('Sm'));
    console.log(n.includes('oh'));
    console.log(`${firstName} `.repeat(5));







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Arrow functions


    const years = [1990, 1965, 1982, 1937];

    // ES5
    var ages5 = years.map(function (el) {
        return 2016 - el;
    });
    console.log(ages5);


    // ES6
    let ages6 = years.map(el => 2016 - el); // one argument and one line of code inside
    console.log(ages6);

    ages6 = years.map((el, index) => `Age element ${index + 1}: ${2016 - el}.`); // two arguments and one line of code
    console.log(ages6);

    ages6 = years.map((el, index) => { // two argument and more than one line of code
        const now = new Date().getFullYear();
        const age = now - el;
        return `Age element ${index + 1}: ${age}.`
    });
    console.log(ages6);







    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Arrow functions 2 (lexical this keyword)
    // arrow function don't have their this keyword, they borrow it from the outer function, they have a lexical this keyword

    // ES5
    var box5 = {
        color: 'green',
        position: 1,
        clickMe: function () {

            document.querySelector('.green').addEventListener('click', function () {
                var str = 'This is box number ' + this.position + ' and it is ' + this.color;
                alert(str);
            });
        }
    }
    box5.clickMe(); // not gonna work, coz 'this' only gets assigned in a method call. so using 'this' inside the callback function (the inner anonymous function)
    // is not gonna work because it's just a regular function call. even though box5.clickMe is a method call, but this still won't work inside the inner
    // function coz it's not a method


    // Es5 workaround
    var box5 = {
        color: 'green',
        position: 1,
        clickMe: function () {

            var self = this;
            document.querySelector('.green').addEventListener('click', function () {
                var str = 'This is box number ' + self.position + ' and it is ' + self.color;
                alert(str);
            });
        }
    }
    box5.clickMe(); // now it will work


    // ES6
    const box6 = {
        color: 'green',
        position: 1,
        clickMe: function () {
            document.querySelector('.green').addEventListener('click', () => {
                var str = 'This is box number ' + this.position + ' and it is ' + this.color;
                alert(str);
            });
        }
    }
    box6.clickMe();


    // ES6 2
    const box66 = {
        color: 'green',
        position: 1,
        clickMe: () => { // won't work coz clickMe now is an arrow function, which means that it has a lexical this keyword (the surroundings 'this') which is the global 'this'
            document.querySelector('.green').addEventListener('click', () => {
                var str = 'This is box number ' + this.position + ' and it is ' + this.color;
                alert(str);
            });
        }
    }
    box66.clickMe();

    // ES5
    Person.prototype.myFriends5 = function (friends) {

        var arr = friends.map(function (el) {
            return this.name + ' is friends with ' + el;
        });

        console.log(arr);
    }

    var friends = ['Bob', 'Jane', 'Mark'];
    new Person('John').myFriends5(friends); // won't work coz the inner anonymous function has its own 'this' which is the global onw (coz it's a regular function call)


    // ES5 workaround
    Person.prototype.myFriends5 = function (friends) {

        var arr = friends.map(function (el) {
            return this.name + ' is friends with ' + el;
        }.bind(this));

        console.log(arr);
    }

    var friends = ['Bob', 'Jane', 'Mark'];
    new Person('John').myFriends5(friends); // we set the 'this' keyword manually using bind()


    // ES6
    Person.prototype.myFriends6 = function (friends) {

        var arr = friends.map(el => `${this.name} is friends with ${el}`);

        console.log(arr);
    }

    new Person('Mike').myFriends6(friends);






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Destructuring

    // ES5
    var john = ['John', 26];
    var name = john[0];
    var age = john[1];


    // ES6 Destructuring Arrays
    const [name, age] = ['John', 26];
    console.log(name);
    console.log(age);

    // Destructuring objects
    const obj = {
        firstName: 'John',
        lastName: 'Smith'
    };

    const { // we use curly braces coz we are destructing an object
        firstName, // this will be = to firstName:firstName it's an es6 feature (when the key and the value have the same name) 
        lastName
    } = obj;
    console.log(firstName);
    console.log(lastName);

    // if you wanna use different names 
    const {
        firstName: a,
        lastName: b
    } = obj;
    console.log(a);
    console.log(b);

    // ES6 returning more than one value from a function without the use of objects
    function calcAgeRetirement(year) {
        const age = new Date().getFullYear() - year;
        return [age, 65 - age];
    }


    const [age2, retirement] = calcAgeRetirement(1990);
    console.log(age2);
    console.log(retirement);




    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Arrays
    // we can't use continue or break statements with foreach or map methods
    // a new loop in ES6 is for of


    const boxes = document.querySelectorAll('.box');

    //ES5
    var boxesArr5 = Array.prototype.slice.call(boxes);
    boxesArr5.forEach(function (cur) {
        cur.style.backgroundColor = 'dodgerblue';
    });

    //ES6
    const boxesArr6 = Array.from(boxes);
    Array.from(boxes).forEach(cur => cur.style.backgroundColor = 'dodgerblue');


    //ES5
    for (var i = 0; i < boxesArr5.length; i++) {

        if (boxesArr5[i].className === 'box blue') {
            continue;
        }

        boxesArr5[i].textContent = 'I changed to blue!';

    }


    //ES6
    for (const cur of boxesArr6) {
        if (cur.className.includes('blue')) {
            continue;
        }
        cur.textContent = 'I changed to blue!';
    }


    //ES5
    var ages = [12, 17, 8, 21, 14, 11];

    var full = ages.map(function (cur) {
        return cur >= 18;
    });
    console.log(full);
    console.log(full.indexOf(true));
    console.log(ages[full.indexOf(true)]);


    //ES6
    console.log(ages.findIndex(cur => cur >= 18));
    console.log(ages.find(cur => cur >= 18));
    //The findIndex() method returns the index of the first element in the array that satisfies the provided testing function. Otherwise -1 is returned.








    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Spread operator

    // a really good article on spread operator is :
    // https://medium.com/@patelhemil/utility-of-spread-operator-in-javascript-83c6e157afed


    function addFourAges(a, b, c, d) {
        return a + b + c + d;
    }

    var sum1 = addFourAges(18, 30, 12, 21);
    console.log(sum1);

    //ES5
    var ages = [18, 30, 12, 21];
    var sum2 = addFourAges.apply(null, ages);
    console.log(sum2);

    //ES6
    const sum3 = addFourAges(...ages);
    console.log(sum3);

    // combine arrays
    const familySmith = ['John', 'Jane', 'Mark'];
    const familyMiller = ['Mary', 'Bob', 'Ann'];
    const bigFamily = [...familySmith, 'Lily', ...familyMiller];
    console.log(bigFamily);

    // combine a node list
    const h = document.querySelector('h1');
    const boxes = document.querySelectorAll('.box');
    const all = [h, ...boxes];

    Array.from(all).forEach(cur => cur.style.color = 'purple');

    // merging objects without duplicate keys
    const profile1 = {
        name: 'techsith',
        age: 30
    };
    const profile2 = {
        name: 'techsith',
        age: 40,
        website: 'techsith.com'
    };

    const newProfile = {
        ...profile1,
        ...profile2
    }

    /*
        {
            name: 'techsith',
                age: 40,
                    site: 'techsith.com'
        }
    
    */









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Rest parameters


    //ES5
    function isFullAge5() {
        console.log(arguments); // arguments is an array-like object
        var argsArr = Array.prototype.slice.call(arguments); // convert it to an array

        argsArr.forEach(function (cur) {
            console.log((2016 - cur) >= 18);
        })
    }


    isFullAge5(1990, 1999, 1965);
    isFullAge5(1990, 1999, 1965, 2016, 1987);


    //ES6
    function isFullAge6(...years) { // rest param gives u an array
        years.forEach(cur => console.log((2016 - cur) >= 18));
    }

    isFullAge6(1990, 1999, 1965, 2016, 1987);


    //ES5
    function isFullAge5(limit) { // limit is gonna be only the first element in the array
        var argsArr = Array.prototype.slice.call(arguments, 1); // by adding one as a second param. the slice method will start copying the array from the first index skipping the first element

        argsArr.forEach(function (cur) {
            console.log((2016 - cur) >= limit);
        })
    }


    isFullAge5(16, 1990, 1999, 1965);



    //ES6
    function isFullAge6(limit, ...years) { // limit is gonna be 16 in this case
        years.forEach(cur => console.log((2016 - cur) >= limit));
    }

    isFullAge6(16, 1990, 1999, 1965, 2016, 1987);


    // this one from react-redux course

    return [action.payload.data, ...state]; // state is an array so we're concatenating here
    // using rest parameters, it gives u back an array which
    // starts with action.payload.data





    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Default parameters


    // ES5
    function SmithPerson(firstName, yearOfBirth, lastName, nationality) {

        lastName === undefined ? lastName = 'Smith' : lastName = lastName;
        nationality === undefined ? nationality = 'american' : nationality = nationality;

        this.firstName = firstName;
        this.lastName = lastName;
        this.yearOfBirth = yearOfBirth;
        this.nationality = nationality;
    }


    //ES6
    function SmithPerson(firstName, yearOfBirth, lastName = 'Smith', nationality = 'american') {
        this.firstName = firstName;
        this.lastName = lastName;
        this.yearOfBirth = yearOfBirth;
        this.nationality = nationality;
    }


    var john = new SmithPerson('John', 1990);
    var emily = new SmithPerson('Emily', 1983, 'Diaz', 'spanish');






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Maps
    // the key difference between maps and objects is that with maps we can use anything for keys not just strings as in objects
    // you can loop through maps but you can't do this with arrays

    const question = new Map();
    question.set('question', 'What is the official name of the latest major JavaScript version?');
    question.set(1, 'ES5');
    question.set(2, 'ES6');
    question.set(3, 'ES2015');
    question.set(4, 'ES7');
    question.set('correct', 3);
    question.set(true, 'Correct answer :D');
    question.set(false, 'Wrong, please try again!');

    console.log(question.get('question'));
    console.log(question.size); // 8


    if (question.has(4)) {
        question.delete(4);
    }

    question.clear(); // to clear all the map


    question.forEach((value, key) => console.log(`This is ${key}, and it's set to ${value}`));


    for (let [key, value] of question.entries()) { // using Destructuring with for of
        if (typeof (key) === 'number') {
            console.log(`Answer ${key}: ${value}`);
        }
    }

    const ans = parseInt(prompt('Write the correct answer'));
    console.log(question.get(ans === question.get('correct')));










    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Classes
    // class definitions are not hoisted unlike function constructors
    // we can only add method to classes (it's not recommended anyway to add properties to classes)
    // functions are balled methods inside the class, so you create them without the function keyword

    // https://www.digitalocean.com/community/tutorials/understanding-classes-in-javascript
    // https://medium.com/beginners-guide-to-mobile-web-development/super-and-extends-in-javascript-es6-understanding-the-tough-parts-6120372d3420


    // classes version (inheritance)
    class Hero {
        constructor(name, level) {
            this.name = name;
            this.level = level;
        }
        greet() {
            return `${this.name} says hello.`;
        }
    }
    class Mage extends Hero {
        constructor(name, level, spell) {
            // Chain constructor with super
            super(name, level);
            // Add a new property
            this.spell = spell;
        }
    }
    const hero2 = new Mage('Lejon', 2, 'Magic Missile');



    // constructor function version (inheritance)
    function Hero(name, level) {
        this.name = name;
        this.level = level;
    }

    Hero.prototype.greet = function () {
        return `${this.name} says hello.`;
    }

    function Mage(name, level, spell) {
        // Chain constructor with call
        Hero.call(this, name, level);
        this.spell = spell;
    }
    const hero2 = new Mage('Lejon', 2, 'Magic Missile');





    // super and extends in action 

    // Es6 Version
    class Animal {
        constructor(name, weight) {
            this.name = name;
            this.weight = weight;
        }

        eat() {
            return `${this.name} is eating!`;
        }

        sleep() {
            return `${this.name} is going to sleep!`;
        }

        wakeUp() {
            return `${this.name} is waking up!`;
        }

    }

    class Gorilla extends Animal {
        constructor(name, weight) {
            super(name, weight);
        }

        climbTrees() {
            return `${this.name} is climbing trees!`;
        }

        poundChest() {
            return `${this.name} is pounding its chest!`;
        }

        showVigour() {
            return `${super.eat()} ${this.poundChest()}`;
        }

        dailyRoutine() {
            return `${super.wakeUp()} ${this.poundChest()} ${super.eat()} ${super.sleep()}`;
        }

    }

    function display(content) {
        console.log(content);
    }

    const gorilla = new Gorilla('George', '160Kg');
    display(gorilla.poundChest());      // George is pounding its chest!
    display(gorilla.sleep());           // George is going to sleep!
    display(gorilla.showVigour());      // George is eating! George is pounding its chest!
    display(gorilla.dailyRoutine());    // George is waking up! George is pounding its chest! George is eating! George is going to sleep!



    // Es5 Version
    function Animal(name, weight) {
        this.name = name;
        this.weight = weight;
    }

    Animal.getName = function () { return "Animal" } // static member example

    Animal.prototype.eat = function () {
        return `${this.name} is eating!`;
    }

    Animal.prototype.sleep = function () {
        return `${this.name} is going to sleep!`;
    }

    Animal.prototype.wakeUp = function () {
        return `${this.name} is waking up!`;
    }


    function Gorilla(name, weight) {
        Animal.call(this, name, weight);
    }

    Gorilla.prototype = Object.create(Animal.prototype);
    Gorilla.prototype.constructor = Gorilla;

    Gorilla.prototype.climbTrees = function () {
        return `${this.name} is climbing trees!`;
    }

    Gorilla.prototype.poundChest = function () {
        return `${this.name} is pounding its chest!`;
    }

    Gorilla.prototype.showVigour = function () {
        return `${Animal.prototype.eat.call(this)} ${this.poundChest()}`;
    }

    Gorilla.prototype.dailyRoutine = function () {
        return `${Animal.prototype.wakeUp.call(this)} ${this.poundChest()} ${Animal.prototype.eat.call(this)} ${Animal.prototype.sleep.call(this)}`;
    }

    function display(content) {
        console.log(content);
    }

    var gorilla = new Gorilla('George', '160Kg');
    display(gorilla.poundChest());      // George is pounding its chest!
    display(gorilla.sleep());           // George is going to sleep!
    display(gorilla.showVigour());      // George is eating! George is pounding its chest!
    display(gorilla.dailyRoutine());    // George is waking up! George is pounding its chest! George is eating! George is going to sleep!





    //ES5
    var Person5 = function (name, yearOfBirth, job) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.job = job;
    }

    Person5.prototype.calculateAge = function () {
        var age = new Date().getFullYear - this.yearOfBirth;
        console.log(age);
    }

    var john5 = new Person5('John', 1990, 'teacher');

    //ES6
    class Person6 {
        constructor(name, yearOfBirth, job) {
            this.name = name;
            this.yearOfBirth = yearOfBirth;
            this.job = job;
        }

        calculateAge() {
            var age = new Date().getFullYear - this.yearOfBirth;
            console.log(age);
        }

        static greeting() {
            console.log('Hey there!');
        }
    }

    const john6 = new Person6('John', 1990, 'teacher');

    Person6.greeting();


    // the class syntax has two components: class expressions and class declarations.

    // class declaration:
    class Rectangle {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    }

    /* Hoisting:
        An important difference between function declarations and class declarations is that function declarations are hoisted and class 
        declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw an error 
        Class expressions are subject to the same hoisting restrictions as well. 
    */

    /* Class expressions:
        Class expressions can be named or unnamed. The name given to a named class expression can be retrieved 
        through the class's (not an instance's) .name property. 
    */

    // unnamed
    let Rectangle = class {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    };
    console.log(Rectangle.name);
    // output: "Rectangle"

    // named
    let Rectangle = class Rectangle2 {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    };
    console.log(Rectangle.name);
    // output: "Rectangle2"


    /* Constructor 
        The constructor method is a special method for creating and initializing an object created with a class. There can only be 
        one special method with the name "constructor" in a class. A SyntaxError will be thrown if the class contains more than one 
        occurrence of a constructor method.
    */

    class Rectangle {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
        // Getter
        get area() { // acts as a property 
            return this.calcArea();
        }
        // Method
        calcArea() {
            return this.height * this.width;
        }
    }

    const square = new Rectangle(10, 10);

    console.log(square.area); // 100


    /* Static Methods
        The static keyword defines a static method for a class. Static methods are called without instantiating their class and 
        cannot be called through a class instance. Static methods are often used to create utility functions for an application.
    */

    /* prototype and static methods 
        When a static or prototype method is called without a value for this, the this value will be undefined inside the method. 
        This behavior will be the same even if the "use strict" directive isn't present, because code within the class body's 
        syntactic boundary is always executed in strict mode.
    */
    class Animal {
        speak() {
            return this;
        }
        static eat() {
            return this;
        }
    }

    let obj = new Animal();
    obj.speak(); // Animal {}
    let speak = obj.speak;
    speak(); // undefined

    Animal.eat() // class Animal
    let eat = Animal.eat;
    eat(); // undefined


    /* function-based syntax
        If the above is written using traditional function-based syntax, then autoboxing in method calls will happen in nonâ€“strict mode based on the initial this value. If the initial value is undefined, this will be set to the global object.
    */

    function Animal() { }

    Animal.prototype.speak = function () {
        return this;
    }

    Animal.eat = function () {
        return this;
    }

    let obj = new Animal();
    let speak = obj.speak;
    speak(); // global object

    let eat = Animal.eat;
    eat(); // global object









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lecture: Classes and subclasses


    //ES5
    var Person5 = function (name, yearOfBirth, job) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.job = job;
    }

    Person5.prototype.calculateAge = function () {
        var age = new Date().getFullYear() - this.yearOfBirth;
        console.log(age);
    }

    var Athlete5 = function (name, yearOfBirth, job, olymicGames, medals) {
        Person5.call(this, name, yearOfBirth, job);
        this.olymicGames = olymicGames;
        this.medals = medals;
    }

    Athlete5.prototype = Object.create(Person5.prototype); // that's how you extend the super class


    Athlete5.prototype.wonMedal = function () { // this method is only attached to the subclass
        this.medals++;
        console.log(this.medals);
    }


    var johnAthlete5 = new Athlete5('John', 1990, 'swimmer', 3, 10);

    johnAthlete5.calculateAge();
    johnAthlete5.wonMedal();


    //ES6
    class Person6 {
        constructor(name, yearOfBirth, job) {
            this.name = name;
            this.yearOfBirth = yearOfBirth;
            this.job = job;
        }

        calculateAge() {
            var age = new Date().getFullYear() - this.yearOfBirth;
            console.log(age);
        }
    }

    class Athlete6 extends Person6 { // that's how you extend a super class in js
        constructor(name, yearOfBirth, job, olympicGames, medals) {
            super(name, yearOfBirth, job);
            this.olympicGames = olympicGames;
            this.medals = medals;
        }

        wonMedal() {
            this.medals++;
            console.log(this.medals);
        }
    }

    const johnAthlete6 = new Athlete6('John', 1990, 'swimmer', 3, 10);

    johnAthlete6.wonMedal();
    johnAthlete6.calculateAge();






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Asynchronous JavaScript
    // setTimeOUt takes additional params as arguments to pass to the callback
    const second = () => {
        setTimeout(() => {
            console.log('Async Hey there');
        }, 2000);
    }

    const first = () => {
        console.log('Hey there');
        second();
        console.log('The end');
    }

    first();






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // From Callback Hell to Promises
    // promises is a new feature in ES6 to escape nested callbacks (setTimeOut)
    // promise : object that keeps track about whether a certain event has happened or not
    // and determine what happens after

    // That's the callback hell without promises (the old way). hard to manage
    function getRecipe() {
        setTimeout(() => {
            const recipeID = [523, 883, 432, 974];
            console.log(recipeID);

            setTimeout(id => {
                const recipe = {
                    title: 'Fresh tomato pasta',
                    publisher: 'Jonas'
                };
                console.log(`${id}: ${recipe.title}`);

                setTimeout(publisher => {
                    const recipe2 = {
                        title: 'Italian Pizza',
                        publisher: 'Jonas'
                    };
                    console.log(recipe);
                }, 1500, recipe.publisher);

            }, 1500, recipeID[2]);

        }, 1500);
    }
    getRecipe();

    /*
    to create a promise : new Promise (function (resolve, reject){ }) 
    it takes a callback function and this callback has two arguments which are functions to be called later
    and returns a promise which you can then consume.
    inside this callback you check, if the promise is fulfilled call resolve with the result 
    if not call reject. 

    consuming a promise :

    myPromise.then(function (fromResolve) { 
        // do something with returned result 
    }).catch (function (){ // catch is called in case the promise fails 

    })
    */


    // the New Way Using Promises
    // this example create three promises, execute the first one immediately and store the other
    // two promises in two constants.
    // after run (creating the first promise) it consumes it using then method.
    // and within the then method it makes use of the other two promises.
    // the reason why it only use the other two promises inside the then method, is because
    // the then method is only called if the resolve method was called which means the call was successful
    // if the call fails reject method would be called and catch would be called instead of then

    const getIDs = new Promise((resolve, reject) => { // returns a promise
        setTimeout(() => {
            resolve([523, 883, 432, 974]);
        }, 1500);
    });

    const getRecipe = recID => { // arrow fun that takes recID as a param
        return new Promise((resolve, reject) => {
            setTimeout(ID => {
                const recipe = {
                    title: 'Fresh tomato pasta',
                    publisher: 'Jonas'
                };
                resolve(`${ID}: ${recipe.title}`);
            }, 1500, recID);
        });
    };

    const getRelated = publisher => {
        return new Promise((resolve, reject) => {
            setTimeout(pub => {
                const recipe = {
                    title: 'Italian Pizza',
                    publisher: 'Jonas'
                };
                resolve(`${pub}: ${recipe.title}`);
            }, 1500, publisher);
        });
    };

    getIDs // now it's easy to escape callback hell because of object chaining
        .then(IDs => { // then receives its param from the resolve method
            console.log(IDs);
            return getRecipe(IDs[2]); // then method returns the second promise we made
        })
        .then(recipe => {
            console.log(recipe);
            return getRelated('Jonas Schmedtmann');
        })
        .then(recipe => {
            console.log(recipe);
        })
        .catch(error => {
            console.log('Error!!');
        });



    // new example from youtube 

    let cleanRoom = function () {
        return new Promise(function (resolve, reject) {
            resolve('Cleaned The Room');
        });
    };

    let removeGarbage = function (message) {
        return new Promise(function (resolve, reject) {
            resolve(message + ' remove Garbage');
        });
    };

    let winIcecream = function (message) {
        return new Promise(function (resolve, reject) {
            resolve(message + ' won Icecream');
        });
    };

    Promise.all([cleanRoom(), removeGarbage(), winIcecream()]).then(function () {
        console.log('all finished')
    }); // this takes an array of all the promises and calls then after all of them are done

    Promise.race([cleanRoom(), removeGarbage(), winIcecream()]).then(function () {
        console.log('all finished')
    }); // this takes an array of all the promises and calls then after anyone of them has finished  






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // From Promises to AsyncAwait
    // AsyncAwait is a way of consuming promises and not producing them
    // every async function returns a promise

    const getIDs = new Promise((resolve, reject) => { // returns a promise
        setTimeout(() => {
            resolve([523, 883, 432, 974]);
        }, 1500);
    });

    const getRecipe = recID => { // arrow fun that takes recID as a param
        return new Promise((resolve, reject) => {
            setTimeout(ID => {
                const recipe = {
                    title: 'Fresh tomato pasta',
                    publisher: 'Jonas'
                };
                resolve(`${ID}: ${recipe.title}`);
            }, 1500, recID);
        });
    };

    const getRelated = publisher => {
        return new Promise((resolve, reject) => {
            setTimeout(pub => {
                const recipe = {
                    title: 'Italian Pizza',
                    publisher: 'Jonas'
                };
                resolve(`${pub}: ${recipe.title}`);
            }, 1500, publisher);
        });
    };

    async function getRecipesAW() { // using AsyncAwait to consume promises
        const IDs = await getIDs; // await stops the execution till it gets the result from resolve method
        console.log(IDs);
        const recipe = await getRecipe(IDs[2]);
        console.log(recipe);
        const related = await getRelated('Jonas Schmedtmann');
        console.log(related);

        return recipe;
    }
    const rec = getRecipeAw();
    console.log(rec); // won't work coz by the time we reach this line getRecipeAw will have been still running at the background but since it returns a promise we can use then method as a workaround which receives an argument from
    getRecipesAW().then(result => console.log(`${result} is the best ever!`));










    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Making AJAX Calls with Fetch and Promises
    // fetch is not supported by all the browsers
    // using fetch is two-step process, you wait for the response and then convert it to json format
    // an alternative is using a popular http request library called 'axios'
    // with this library the response is automatically converted to json, plus it has better error handling


    function getWeather(woeid) { // https://crossorigin.me/ or https://cors-anywhere.herokuapp.com/ is a way of solving the same origin problem
        fetch(`https://crossorigin.me/https://www.metaweather.com/api/location/${woeid}/`)
            .then(result => {
                // console.log(result);
                return result.json();
            })
            .then(data => {
                // console.log(data);
                const today = data.consolidated_weather[0]; // 0 index contains the first day
                console.log(
                    `Temperatures today in ${data.title} stay between ${today.min_temp} and ${today.max_temp}.`
                );
            })
            .catch(error => console.log(error));
    }
    getWeather(2487956);
    getWeather(44418);









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Making AJAX Calls with Fetch and AsyncAwait
    // fetch is not supported by all browsers

    async function getWeatherAW(woeid) {
        try {
            const result = await fetch(`https://crossorigin.me/https://www.metaweather.com/api/location/${woeid}/`);
            const data = await result.json();
            const tomorrow = data.consolidated_weather[1];
            console.log(
                `Temperatures tomorrow in ${data.title} stay between ${tomorrow.min_temp} and ${tomorrow.max_temp}.`
            );
            return data;
        } catch (error) {
            alert(error);
        }
    }
    getWeatherAW(2487956);

    let dataLondon;
    getWeatherAW(44418).then(data => {
        dataLondon = data
        console.log(dataLondon);
    });









    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting and importing

    //file1.js
    export default 'exported string';
    //file2.js
    import str from '.models/Search'; // you don't have to specify the extension of the file

    // if you wanna export multiple things use named import
    // file1.js
    export const add = (a, b) => a + b;
    export const multiply = (a, b) => a * b;
    export const ID = 23;
    // file2.js
    import {
        add,
        multiply,
        ID
    } from './views/searchView'; // or import {add as a,multiply as m,ID} from './views/searchView';
    console.log(`using the function ${add(ID, 2)}`);
    // or
    import * as searchView from './views/searchView';
    console.log(`using the function ${searchView.add(searchView.ID, 2)}`);












    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful Code


    // useful packages and libraries :
    axios
    html - webpack - plugin
    fractional
    uniqid
    localstorage // important linke =>  https://www.quora.com/Is-localStorage-deleted-once-the-user-closes-the-browser-or-the-tab

    // localstorage is a function that lives in the window object(global object) 
    // localstorage.setItem(string,string)  it takes key-value pair
    // to store an array as a string use : JSON.stringfy(array) to convert it back use : JSON.parse()
    // localstorage.getItem(key)



    // how to get the size of the viewport
    // viewport is : is the part of the webpage that the user can currently see. The scrollbars move the viewport to show other parts of the page.
    if (typeof window.innerWidth != 'undefined') {
        viewportwidth = window.innerWidth,
            viewportheight = window.innerHeight
    }



    // the difference between parentElement and parentNode
    // https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement



    // how to remove an element in Js
    // https://stackoverflow.com/questions/3387427/remove-element-by-id#
    // or just use this:
    // el.parentNode.removeChild(el);



    // return key event:
    document.addEventListener('keypress', function (event) {
        if (event.keyCode === 13 || event.which === 13) {
            console.log('Enter was pressed');
        }
    })



    // if you have too many query strings in your script use this method
    var DOMstrings = { // this make it easier when you want to change the strings later
        inputType: '.add__type', // coz now you will only have to change the object and not all the occurrences
        inputDescription: '.desc'
    };



    // element.insertAdjacentHTML(position, text);



    // how to convert the list returned from document.querySelectorAll(); to an array ?
    fields = document.querySelector();
    fieldsArr = Array.prototype.slice.call(fields); // we can't call slice directly because fields is a list not an array
    // that's why we need to borrow the slice method



    // to set the focus on an element use this :
    element.focus();



    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Json 

    // some Rules :
    // uses key/value pairs 
    // double quotes around key and value
    // file type is .json
    // MiME type is "Application/json"


    // Json Data Types 
    // Numbers : no difference between integer and floats
    // String  : 
    // Boolean : 
    // Array   :
    // Object  : Key/value Pairs
    // Null    : Empty value


    // normal array
    var people = [
        {
            name: "Brad",
            age: 35
        },
        {
            name: "John",
            age: 40
        },
        {
            name: "Sara",
            age: 25
        }
    ];

    // converted to Json format
    /* {
        "people": [
        {
            "name":"Brad",
            "age": 35
        },
        {
            "name":"John",
            "age":40
        },
        {
            "name":"Sara",
            "age":25
        },
        {
            "name":"Jeff",
            "age":20
        }
        ]
    } */





    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Chrome Dev Tools 


    // console.error('An error');
    // console.warn('A warning');
    // console.dir(document);

    // console.table([{name:'John', email:'test@test.com', age:33}]);
    // console.clear();

    // console.group('Say Hello'); 
    //   console.log('Hello Brad');
    //   console.log('Hello John');
    //   console.log('Hello Sally');
    // console.groupEnd('Say Hello');

    // console.time('Run Loop');
    // for (var i = 0; i < 20000; i++) {
    //     console.log(i);
    // };
    // console.timeEnd('Run Loop');
    // function greaterThan(a,b) {
    //   console.assert(a > b, {"message":"a is not greater than b","a":a,"b":b});
    // }

    // greaterThan(5,6);





</script>



</html>